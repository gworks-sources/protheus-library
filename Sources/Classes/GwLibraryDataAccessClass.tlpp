#include "TOTVS.ch"
#include "MsObject.ch"

#define PAR_DATASOURCE_REQUIRE .T.
#define PAR_DATASOURCE_NOT_REQUIRE .F.

using namespace Gworks.Library.Utils
using namespace Gworks.library.Functions

namespace Gworks.Library.Classes

Class GwDataAccess

    // Dados principais
    Public Data cAlias      as character default ""
    Public Data cDataSource as character default ""
    Public Data aQuery      as array default {}
    Public Data lOppened    as logical default .F.
    Public Data nRecnoId    as numeric default 0

    // Atributos de controle de área
    Public Data aAliasArea  as array default {}
    Public Data aOtherAreas as array default {}

    // Atributos de controle de relacionamento com demais entidades
    Public Data aRelation   as array default {}
    Public Data oRelation   as object default nil

    // Atributos de manipulação de índices
    Public Data nIndexOrd   as numeric default 0
    Public Data cIndexKey   as character default ""
    Public Data lAutoFilial as logical default .T.
    Public Data lFound      as logical default .F.

    Public Method New() Constructor
    Public Method SetDataSource( cDataSource as character ) as variant
    Public Method SelectArea() as variant
    Public Method SetOrder( xOrder as variant )
    Public Method RetIndexOrder() as numeric
    Public Method GoTop() as variant
    Public Method GoBottom() as variant
    Public Method GoToRecno( nRecno as numeric ) as logical
    Public Method SkipLine() as variant
    Public Method EnableAutoFilial() as variant
    Public Method DisableAutoFilial() as variant
    Public Method SeekStatus() as logical
    Public Method Seek( cKey as character ) as logical
    Public Method SaveArea() as variant
    Public Method SaveOtherAreas( aNames as array )
    Public Method RestoreArea() as variant
    Public Method RestoreOtherAreas( cNames as character ) as variant
    Public Method EraseArea() as variant
    Public Method EraseOtherAreas() as variant
    Public Method EvalByCondition( bExec as codeblock, bCondition as codeblock ) as variant
    Public Method GetValue( cName as character ) as variant
    Public Method EndOfFile() as logical
    Public Method NotEndOfFile() as logical
    Public Method TotalLines() as numeric
    Public Method Oppened() as logical
    Public Method CloseArea() as variant
    Public Method ReleaseArea() as variant
    Public Method GetRecnoId() as variant

    Public Method SetRelation() as variant
    Public Method SelectRelation( cAliasJoin as character, cIndexJoin as character ) as logical
    Public Method RelationJoin( cAliasJoin as character, cIndexJoin as character ) as logical
    Public Method RelationSearch( cFieldName as character, xContent as variant, cRetJoinId as character ) as logical
    Public Method RelationGetValue( cFieldName as character ) as object


    Private Method ValidDataSource( lRequireDictionary as logical ) as logical


EndClass


Method New( cAlias as character ) Class GwDataAccess

    Default cAlias := ""

    if Empty(cAlias)
        UserException("GwDataAccess:New - Argumento cAlias inválido ou não informado!")
    endif

    Self:SelectArea()
    Self:SetDataSource()

    Self:cAlias      := cAlias
    Self:lOppened    := Select(cAlias) > 0
    Self:aAliasArea  := (cAlias)->(GetArea())
    Self:aOtherAreas := {}
    Self:aRelation   := {}
    Self:lAutoFilial := .T.

    if ::lOppened
        ::nIndexOrd := (cAlias)->(IndexOrd())
        ::cIndexKey := (cAlias)->(IndexKey(::nIndexOrd))
        ::nRecnoId  := (cAlias)->(Recno())
    endif

Return Self


Method SetDataSource( cDataSource as character ) as variant Class GwDataAccess

    Default cDataSource := "SX2"

    if !(cDataSource $ "SX2;SQL")
        UserException("GwDataAccess:SetDataSource - Argumento cDataSource inválido!")
    endif

    Self:cDataSource := cDataSource

Return


Method ValidDataSource( lRequireDictionary as logical ) as logical Class GwDataAccess

    Default lRequireDictionary := .T.

    if lRequireDictionary .And. ::cDataSource != "SX2"
        UserException("GwDataAccess:ValidDataSource - Acesso a método inválido para o DataSource " +'"'+ ::cDataSource +'"!')
    endif

Return .T.


Method SelectArea() as variant Class GwDataAccess

    DbSelectArea(Self:cAlias)

Return


Method SetOrder( xOrder as variant )  as variant Class GwDataAccess

    Local cAlias := "" as character

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    cAlias := Self:cAlias

    ::nIndexOrd := 0
    ::cIndexKey := ""

    do case

        case Val(xOrder) == 'N' ; (cAlias)->(DbSetOrder(xOrder))

        case Val(xOrder) == "C" ; (cAlias)->(DbSetOrder(RetOrder(,xOrder)))

        otherwise
            UserException("GwDataAccess:SetOrder - Argumento xOrder inválido!")

    endcase

    ::nIndexOrd := (cAlias)->(IndexOrd())
    ::cIndexKey := (cAlias)->(IndexKey(::nIndexOrd))

    (cAlias)->(DbGoTop())

Return


Method RetIndexOrder() as numeric Class GwDataAccess

    Local cAlias := "" as character
    Local nOrder := 0 as numeric

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    cAlias := Self:cAlias

    nOrder := (cAlias)->(IndexOrd())

Return nOrder


Method GoTop() as variant Class GwDataAccess

    Local cAlias := "" as character

    cAlias := Self:cAlias

    (cAlias)->(DbGoTop())

Return


Method GoBottom() as variant Class GwDataAccess

    Local cAlias := "" as character

    cAlias := Self:cAlias

    (cAlias)->(DbGoBottom())

Return


Method GoToRecno( nRecno as numeric ) as logical Class GwDataAccess

    Local cAlias  := ""  as character
    Local lResult := .F. as logical

    Default nRecno := 0

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    if nRecno > 0

        cAlias := Self:cAlias

        (cAlias)->(DbGoTo(nRecno))

        if (cAlias)->(Recno()) == nRecno
            lResult := .T.
        endif

    endif

Return lResult


Method SkipLine() as variant Class GwDataAccess

    Local cAlias := "" as character

    cAlias := Self:cAlias

    (cAlias)->(DbSkip())

Return


Method EnableAutoFilial() as variant Class GwDataAccess
    ::lAutoFilial := .T.
Return


Method DisableAutoFilial() as variant Class GwDataAccess
    ::lAutoFilial := .F.
Return


Method SeekStatus( cKey as character ) as logical Class GwDataAccess

    Local cAlias  := ""  as character
    Local lResult := .F. as logical

    Default cKey  := ""

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    cAlias := ::cAlias

    if !Empty(cAlias) .And. Select(cAlias) > 0 .And. (cAlias)->(IndexOrd) == ::nIndexOrd .And. !(cAlias)->(EOF())

        if !Empty(::cIndexKey) .And. !Empty(cKey)

            cKey += iif( ::lAutoFilial, xFilial(cAlias), "" )

            lResult := ( (cAlias)->(&::cIndexKey) == cKey )

        else

            lResult := .T.

        endif

    endif

Return lResult


Method Seek( cKey as character ) as logical Class GwDataAccess

    Local cAlias  := ""  as character
    Local lResult := .F. as logical

    Default cKey := ""

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    if Empty(cKey)
        UserException("GwDataAccess:Seek - Parâmetro cKey não informado!")
    endif

    if Empty(::cIndexKey)
        UserException("GwDataAccess:Seek - Alias sem index definido!")
    endif

    cAlias := ::cAlias

    if ::SeekStatus(cKey)

        lResult := .T.

    else

        cKey += iif( ::lAutoFilial, xFilial(cAlias), "" )

        if (cAlias)->(MsSeek(cKey))

            lResult := .T.

        endif

    endif

    ::nRecnoId := 0
    ::lFound   := .F.
    if lResult
        ::nRecnoId := (cAlias)->(Recno())
        ::lFound   := .T.
    endif

Return lResult


Method SaveArea() as variant Class GwDataAccess

    Local cAlias := "" as character

    cAlias := Self:cAlias

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    if !Empty(Self:aAliasArea)
        Self:EraseArea()
    endif

    Self:aAliasArea := (cAlias)->(GetArea())

Return


Method SaveOtherAreas( aNames as array ) as variant Class GwDataAccess

    Local aAreas := {} as array
    Local cAlias := "" as character
    Local nI     := 0  as numeric

    Default aNames := {}

    for nI:=1 to Len(aNames)

        cAlias := aNames[nI]

        aAdd( aAreas, (cAlias)->(GetArea()) )

    next

    Self:aOtherAreas := aClone(aAreas)

Return


Method RestoreArea() as variant Class GwDataAccess

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    RestArea(Self:aAliasArea)

    ::nIndexOrd := (cAlias)->(IndexOrd())
    ::cIndexKey := (cAlias)->(IndexKey(::nIndexOrd))
    ::nRecnoId  := (cAlias)->(Recno())

Return


Method RestoreOtherAreas( cNames as character ) as variant Class GwDataAccess

    Local aAreas := {} as array
    Local cName  := "" as character
    Local cToken := "" as character
    Local nI     := 0  as numeric
    Local nJ     := 0  as numeric
    Local nPos   := 0  as numeric

    Default cNames := ""

    if Empty(cNames)
        Return
    endif

    cToken := ";"

    aNames := if( at(cNames,cToken) > 0, StrToKarr(cNames,cToken), { cNames } )

    For nI:=1 to Len(aNames)

        cName := aNames[nI]

        if !Empty(cName)
            nPos := aScan(Self:aOtherAreas, {|x| x[1]==cName})
        endif

        for nJ:=1 to Len(Self:aOtherAreas)

            if nPos > 0 .And. nJ != nPos
                loop
            endif

            aAreas := Self:aOtherAreas[nJ]

            RestArea(aAreas[nJ])

        next nJ

    next nI

Return


Method EraseArea() as variant Class GwDataAccess

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    FwFreeArray(Self:aAliasArea)
    Self:aAliasArea := {}

Return


Method EraseOtherAreas() as variant Class GwDataAccess

    FwFreeArray(Self:aOtherAreas)
    Self:aOtherAreas := {}

Return


Method EvalByCondition( bExec as codeblock, bCondition as codeblock ) as variant Class GwDataAccess

    Local cAlias := "" as character

    Default bExec := {|| }
    Default bCondition := {|| }

    if !Empty(bExec) .And. !Empty(bCondition)

        cAlias := Self:cAlias

        (cAlias)->( DbEval( bExec, nil, bCondition ) )

    endif

Return


Method GetValue( cName as character ) as variant Class GwDataAccess

    Local cAlias := ""  as character
    Local xRet   := nil as variant

    Default cName := ""

    if !Empty(cName)

        cAlias := Self:cAlias

        xRet := (cAlias)->&cName

    endif

Return xRet


Method EndOfFile() as logical Class GwDataAccess

Return (Self:cAlias)->(EOF())


Method NotEndOfFile() as logical Class GwDataAccess

Return !(Self:cAlias)->(EOF())


Method TotalLines() as numeric Class GwDataAccess

    Local cAlias := "" as character
    Local nTotal := 0  as numeric

    cAlias := Self:cAlias
    nTotal := Contar(cAlias,"!EOF()")

    (cAlias)->(DbGoTop())

Return nTotal


Method Oppened() as logical Class GwDataAccess

Return ::lOppened


Method CloseArea() as variant Class GwDataAccess

    Local cAlias := ""  as character

    cAlias := Self:cAlias

    (cAlias)->(DbCloseArea())

Return


Method ReleaseArea() as variant Class GwDataAccess

    Local cAlias := ""  as character

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    cAlias := Self:cAlias

    do case
        case  ::lOppened ; ::RestArea()
        case !::lOppened ; ::CloseArea()
    endcase

Return


Method GetRecnoId() Class GwDataAccess

    Local cAlias := "" as character

    ::ValidDataSource(PAR_DATASOURCE_REQUIRE)

    cAlias := Self:cAlias

Return (cAlias)->(Recno())


Method SetRelation( aAttr as array,  ) as variant Class GwDataAccess

    Local cAliasFrom     := "" as character
    Local cAliasJoin     := "" as character
    Local cIndexFrom     := "" as character
    Local cIndexJoin     := "" as character
    Local cFieldIdFrom   := "" as character
    Local cFieldIdJoin   := "" as character
    Local cFieldIdJoinFK := "" as character

    Local oRelation := nil as object

    cAliasFrom     := ::cAlias
    cAliasJoin     := if( ValType(aAttr[1]) == "C", aAttr[1], "" )
    cIndexFrom     := if( ValType(aAttr[2]) == "C", aAttr[2], "" )
    cIndexJoin     := if( ValType(aAttr[3]) == "C", aAttr[3], "" )
    cFieldIdFrom   := if( ValType(aAttr[4]) == "C", aAttr[4], "" )
    cFieldIdJoin   := if( ValType(aAttr[5]) == "C", aAttr[5], "" )
    cFieldIdJoinFK := if( ValType(aAttr[6]) == "C", aAttr[6], "" )

    oRelation := GwDataRelationClass():New()
    oRelation:SetAliasFrom(cAliasFrom)
    oRelation:SetAliasJoin(cAliasJoin)
    oRelation:SetIndexFrom(cIndexFrom)
    oRelation:SetIndexJoin(cIndexJoin)
    oRelation:SetFieldIdFrom(cFieldIdFrom)
    oRelation:SetFieldIdJoin(cFieldIdJoin)
    oRelation:SetFieldIdJoinFK(cFieldIdJoinFK)

    oRelation:RelationJoin()

    ::oRelation := oRelation

    aAdd(::aRelation, oRelation)

Return


Method SelectRelation( cAliasJoin as character, cIndexJoin as character ) as logical Class GwDataAccess

    Local nI := 0 as numeric
    Local oRelation := nil as object

    Default cAliasJoin := ""
    Default cIndexJoin := ""

    for nI:=1 to Len(::aRelation)

        oRelation := aRelation[nI]
        if oRelation:cAliasJoin == cAliasJoin .And. ( Empty(cIndexJoin) .Or. !Empty(cIndexJoin) .And. oRelation:cIndexJoin == cIndexJoin )
            lResult := .T.
            exit
        endif

    next

    if lResult
        ::oRelation := oRelation
    else
        FwFreeObj(::oRelation)
        ::oRelation := nil
    endif

Return lResult


Method RelationJoin( cAliasJoin as character, cIndexJoin as character ) as logical Class GwDataAccess

    Local lResult := .F.

    Default cAliasJoin := ""
    Default cIndexJoin := ""

    if Empty(cAliasJoin) .Or. ( !Empty(cAliasJoin) .And. ::SelectRelation(cAliasJoin, cIndexJoin) )

        ::oRelation:Join()

        lResult := .T.

    endif

Return lResult


Method RelationSearch( cFieldName as character, xContent as variant, cRetJoinId as character ) as logical Class GwDataAccess

    Local lResult := .F. as logical

    if ::oRelation:Search( cFieldName, xContent, @cRetJoinId )
        lResult := .T.
    endif

Return lResult


Method RelationGetValue( cFieldName as character ) as object Class GwDataAccess

    Local oResult := nil as object

    oResult := ::oRelation:GetValue(cFieldName)

Return oResult
